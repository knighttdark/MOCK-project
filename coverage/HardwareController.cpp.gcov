        -:    0:Source:src/hardware/HardwareController.cpp
        -:    0:Graph:build/objects/src/hardware/HardwareController.gcno
        -:    0:Data:build/objects/src/hardware/HardwareController.gcda
        -:    0:Runs:1
        -:    1:#include "hardware/HardwareController.h"
        -:    2:#include "controller/PlayingMediaController.h"
        -:    3:#include "model/PlayingMediaModel.h"
        -:    4:#include <SDL2/SDL.h>
        -:    5:#include <SDL2/SDL_mixer.h>
        -:    6:#include <taglib/fileref.h>
        -:    7:
        -:    8:/* Constructor: Initializes the hardware communication via the serial port */
    #####:    9:Hardware::Hardware(const string& portName, unsigned int baudRate)
    #####:   10:    : serial(io, portName) {
    #####:   11:    serial.set_option(serial_port_base::baud_rate(baudRate));
    #####:   12:    serial.set_option(serial_port_base::character_size(8));
    #####:   13:    serial.set_option(serial_port_base::parity(serial_port_base::parity::none));
    #####:   14:    serial.set_option(serial_port_base::stop_bits(serial_port_base::stop_bits::one));
    #####:   15:    serial.set_option(serial_port_base::flow_control(serial_port_base::flow_control::none));
    #####:   16:}
        -:   17:
        -:   18:/* Destructor: Ensures the serial port is closed properly */
    #####:   19:Hardware::~Hardware() {
    #####:   20:    if (serial.is_open()) {
    #####:   21:        serial.close();
    #####:   22:        cout << "Serial port closed." << endl;
        -:   23:    }
    #####:   24:}
        -:   25:
        -:   26:/* Start listening for commands from the hardware */
    #####:   27:void Hardware::startListening() {
    #####:   28:    boost::asio::streambuf buffer;
        -:   29:
        -:   30:    while (true) {
        -:   31:        /* Read commands from the serial port */
    #####:   32:        size_t n = read_until(serial, buffer, "\n");
    #####:   33:        istream is(&buffer);
    #####:   34:        string command;
    #####:   35:        command.resize(n);
    #####:   36:        is.read(&command[0], n);
    #####:   37:        command = command.substr(0, is.gcount());
    #####:   38:        handleCommand(command);
    #####:   39:        buffer.consume(n);
    #####:   40:    }
    =====:   41:}
        -:   42:
        -:   43:/* Handle incoming commands from the hardware */
    #####:   44:void Hardware::handleCommand(string& command) {
        -:   45:    /* Remove carriage return and newline characters from the command */
    #####:   46:    command.erase(remove(command.begin(), command.end(), '\r'), command.end());
    #####:   47:    command.erase(remove(command.begin(), command.end(), '\n'), command.end());
        -:   48:
        -:   49:    /* Get the PlayingMediaController instance to perform actions */
    #####:   50:    PlayingMediaController* playingController = dynamic_cast<PlayingMediaController*>(
    #####:   51:                ManagerController::getInstance().getController("PlayingView"));
        -:   52:
        -:   53:    /* Remove the "__" prefix if present */
    #####:   54:    if (command.rfind("__", 0) == 0) {
    #####:   55:        command = command.substr(2);
        -:   56:    }
        -:   57:
    #####:   58:    if (!command.empty() && all_of(command.begin(), command.end(), ::isdigit)) {
        -:   59:        /* Convert the command to a number and adjust the volume */
        -:   60:        try {
    #####:   61:            int rawValue = stoi(command);
    #####:   62:            int mappedValue = rawValue * 100 / 4095;
    #####:   63:            if (abs(mappedValue - currentVolume) >= 2) {
    #####:   64:                playingController->adjustVolume(mappedValue);
    #####:   65:                currentVolume = mappedValue;
        -:   66:            } else {
        -:   67:                /* do nothing */
        -:   68:            }
    =====:   69:        } catch (const exception& e) {
    =====:   70:            cerr << "Error converting command to number: " << e.what() << "\n";
    =====:   71:        }
    #####:   72:    } else if (!command.empty()) {
        -:   73:        /* Handle character-based commands for playback control */
    #####:   74:        if (command == "s") {
        -:   75:            /* Stop the current playback */
    #####:   76:            playingController->stop();
    #####:   77:        } else if (command == "p") {
        -:   78:            /* Skip to the previous track */
    #####:   79:            playingController->skipToPrevious();
    #####:   80:        } else if (command == "c") {
        -:   81:            /* Pause or resume the current media */
    #####:   82:            if (Mix_PausedMusic()) {
    #####:   83:                Mix_ResumeMusic();
    #####:   84:                playingController->setIsPlaying(true);
        -:   85:            } else {
    #####:   86:                Mix_PauseMusic();
    #####:   87:                playingController->setIsPlaying(false);
        -:   88:            }
    #####:   89:        } else if (command == "n") {
        -:   90:            /* Skip to the next track */
    #####:   91:            playingController->skipToNext();
        -:   92:        } else {
    #####:   93:            cerr << "Unknown character command: " << command << "\n";
        -:   94:        }
        -:   95:    } else {
    #####:   96:        cerr << "Invalid or empty command received." << endl;
        -:   97:    }
    #####:   98:}
