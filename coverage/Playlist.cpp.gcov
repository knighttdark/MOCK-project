        -:    0:Source:src/model/Playlist.cpp
        -:    0:Graph:build/objects/src/model/Playlist.gcno
        -:    0:Data:build/objects/src/model/Playlist.gcda
        -:    0:Runs:2
        -:    1:#include "model/Playlist.h"
        -:    2:#include <algorithm>
        -:    3:#include <iostream>
        -:    4:
        8:    5:Playlist::Playlist(const string& playlistName) {
        8:    6:    if (playlistName.empty()) {
    #####:    7:        throw invalid_argument("Playlist name cannot be empty.");
        -:    8:    }
        8:    9:    name = playlistName;
        8:   10:}
        -:   11:
    #####:   12:string Playlist::getName() const {
    #####:   13:    return name;
        -:   14:}
        -:   15:
    #####:   16:const vector<MediaFile>& Playlist::getSongs() const {
    #####:   17:    return songs;
        -:   18:}
        -:   19:
    #####:   20:void Playlist::setName(const string& newName) {
    #####:   21:    if (newName.empty()) {
    #####:   22:        throw invalid_argument("New playlist name cannot be empty.");
        -:   23:    }
    #####:   24:    name = newName;
    #####:   25:}
        -:   26:
        8:   27:void Playlist::addSong(const MediaFile& song) {
        8:   28:    if (!containsSong(song)) {
        8:   29:        songs.push_back(song);
        -:   30:    } else {
    #####:   31:        cerr << "Warning: Song already exists in the playlist.\n";
        -:   32:    }
        8:   33:}
        -:   34:
    #####:   35:void Playlist::removeSong(const MediaFile& song) {
    #####:   36:    auto it = remove_if(songs.begin(), songs.end(),
    #####:   37:                             [&song](const MediaFile& s) {
    #####:   38:                                 return s.getPath() == song.getPath();
        -:   39:                             });
    #####:   40:    if (it != songs.end()) {
    #####:   41:        songs.erase(it, songs.end());
        -:   42:    } else {
    #####:   43:        cerr << "Warning: Song not found in the playlist.\n";
        -:   44:    }
    #####:   45:}
        -:   46:
        8:   47:bool Playlist::containsSong(const MediaFile& song) const {
        8:   48:    return any_of(songs.begin(), songs.end(),
        6:   49:                       [&song](const MediaFile& s) {
        6:   50:                           return s.getPath() == song.getPath();
        8:   51:                       });
        -:   52:}
        -:   53:
    #####:   54:bool Playlist::updateSong(const MediaFile& oldSong, const MediaFile& newSong) {
    #####:   55:    auto it = find_if(songs.begin(), songs.end(),
    #####:   56:                           [&oldSong](const MediaFile& s) {
    #####:   57:                               return s.getPath() == oldSong.getPath();
        -:   58:                           });
    #####:   59:    if (it != songs.end()) {
    #####:   60:        *it = newSong;
    #####:   61:        return true;
        -:   62:    }
    #####:   63:    return false;
        -:   64:}
        -:   65:
    #####:   66:string Playlist::getInfo() const {
    #####:   67:    string info = "Playlist: " + name + "\n";
    #####:   68:    if (songs.empty()) {
    #####:   69:        info += "No songs in the playlist.\n";
        -:   70:    } else {
    #####:   71:        info += "Songs (" + to_string(songs.size()) + "):\n";
    #####:   72:        for (const auto& song : songs) {
    #####:   73:            info += " - " + song.getName() + " (" + song.getPath() + ")\n";
        -:   74:        }
        -:   75:    }
    #####:   76:    return info;
    =====:   77:}
