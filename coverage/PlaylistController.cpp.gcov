        -:    0:Source:src/controller/PlaylistController.cpp
        -:    0:Graph:build/objects/src/controller/PlaylistController.gcno
        -:    0:Data:build/objects/src/controller/PlaylistController.gcda
        -:    0:Runs:2
        -:    1:#include "controller/PlaylistController.h"
        -:    2:#include "controller/ManagerController.h"
        -:    3:#include "model/ManagerModel.h"
        -:    4:#include "common/Enum.h"
        -:    5:#include "common/Exception.h"
        -:    6:#include "view/PlaylistView.h"
        -:    7:#include <iostream>
        -:    8:#include <climits>
        -:    9:#include <controller/PlayingMediaController.h>
        -:   10:#include <bits/this_thread_sleep.h>
        -:   11:#include "common/TerminalUtils.h"
        -:   12:
        -:   13:/* Default constructor for PlaylistController */
        3:   14:PlaylistController::PlaylistController() {}
        -:   15:
        -:   16:/* Function to handle user actions in the playlist view */
    #####:   17:void PlaylistController::handleAction(int action) {
    #####:   18:    switch (action) {
    #####:   19:        case ACTION_CREATE_PLAYLIST: {
        -:   20:            /* Create a new playlist */
    #####:   21:            string name;
    #####:   22:            string placeholder = "Enter new playlist name...";
    #####:   23:            string result_message;
    #####:   24:            Decorator message_style;
        -:   25:
        -:   26:            /* Display an input box for the user to enter the playlist name */
    #####:   27:            auto input_box = Input(&name, placeholder);
    #####:   28:            auto input_renderer = Renderer(input_box, [&] {
    #####:   29:                return vbox({
    #####:   30:                    text("Create New Playlist") | bold | center,
        -:   31:                    separator(),
    #####:   32:                    text("Enter playlist name:") | center,
    #####:   33:                    input_box->Render() | border,
        -:   34:                    separator(),
    #####:   35:                    text("Press ENTER to confirm, ESC to cancel.") | dim | center,
    #####:   36:                }) | center;
    #####:   37:            });
        -:   38:
    #####:   39:            auto screen = ScreenInteractive::TerminalOutput();
    #####:   40:            bool confirmed = false;
        -:   41:
        -:   42:            /* Capture user input for playlist name */
    #####:   43:            auto main_component = CatchEvent(input_renderer, [&](Event event) {
    #####:   44:                if (event == Event::Return) {
    #####:   45:                    confirmed = true;
    #####:   46:                    screen.ExitLoopClosure()();
    #####:   47:                    return true;
        -:   48:                }
    #####:   49:                if (event == Event::Escape) {
    #####:   50:                    confirmed = false;
    #####:   51:                    screen.ExitLoopClosure()();
    #####:   52:                    return true;
        -:   53:                }
    #####:   54:                return false;
    #####:   55:            });
        -:   56:
    #####:   57:            screen.Loop(main_component);
        -:   58:
        -:   59:            /* Handle confirmed or cancelled actions */
    #####:   60:            if (confirmed && !name.empty()) {
    #####:   61:                createPlaylist(name);
    #####:   62:                result_message = "Playlist '" + name + "' created successfully!";
    #####:   63:                message_style = color(Color::Green);
    #####:   64:            } else if (!confirmed) {
    #####:   65:                result_message = "Playlist creation cancelled.";
    #####:   66:                message_style = color(Color::Yellow);
        -:   67:            } else {
    #####:   68:                result_message = "Error: Playlist name cannot be empty.";
    #####:   69:                message_style = color(Color::Red);
        -:   70:            }
        -:   71:
        -:   72:            /* Display the result message */
    #####:   73:            auto result_renderer = Renderer([&] {
    #####:   74:                return vbox({
    #####:   75:                    text(result_message) | bold | message_style | center,
        -:   76:                    separator(),
    #####:   77:                    text("Press ENTER to continue...") | dim | center,
    #####:   78:                }) | center;
    #####:   79:            });
        -:   80:
        -:   81:            /* Capture user input to continue */
    #####:   82:            auto result_component = CatchEvent(result_renderer, [&](Event event) {
    #####:   83:                if (event == Event::Return) {
    #####:   84:                    screen.ExitLoopClosure()();
    #####:   85:                    return true;
        -:   86:                }
    #####:   87:                return false;
    #####:   88:            });
        -:   89:
    #####:   90:            screen.Loop(result_component);
    #####:   91:            clearTerminal();
    #####:   92:            listAllPlaylists();
    #####:   93:            break;
    #####:   94:        }
    #####:   95:        case ACTION_DELETE_PLAYLIST: {
        -:   96:            /* Delete a playlist */
    #####:   97:            deletePlaylist();
    #####:   98:            clearTerminal();
    #####:   99:            listAllPlaylists();
    #####:  100:            break;
        -:  101:        }
    #####:  102:        case ACTION_VIEW_PLAYLIST_DETAILS: {
        -:  103:            /* Displays details of a selected playlist */
    #####:  104:            PlaylistView* playlistView = dynamic_cast<PlaylistView*>(ManagerController::getInstance().getManagerView()->getView());
    #####:  105:            if (!playlistView) {
    #####:  106:                cerr << "Error: PlaylistView is not available.\n";
    #####:  107:                break;
        -:  108:            }
        -:  109:
    #####:  110:            int selected_playlist_ID = playlistView->getSelectedPlaylistID();
        -:  111:
    #####:  112:            PlaylistLibrary& playlistLibrary = ManagerModel::getInstance().getPlaylistLibrary();
    #####:  113:            const auto& playlists = playlistLibrary.getPlaylists();
        -:  114:
    #####:  115:            const string& selected_playlist_name = playlists[selected_playlist_ID - 1].getName();
        -:  116:
    #####:  117:            viewPlaylistDetails(selected_playlist_name);
    #####:  118:            clearTerminal();
    #####:  119:            listAllPlaylists();
    #####:  120:            break;
    #####:  121:        }
    #####:  122:        case ACTION_LIST_ALL_PLAYLISTS:
        -:  123:            /* List all playlists */
    #####:  124:            clearTerminal();
    #####:  125:            listAllPlaylists();
    #####:  126:            break;
    #####:  127:        case ACTION_PLAY_PLAYLISTS: {
        -:  128:            /* Play the selected playlist */
    #####:  129:            PlaylistView* playlistView = dynamic_cast<PlaylistView*>(ManagerController::getInstance().getManagerView()->getView());
    #####:  130:            if (!playlistView) {
    #####:  131:                cerr << "Error: PlaylistView is not available.\n";
    #####:  132:                break;
        -:  133:            }
        -:  134:
    #####:  135:            int selected_playlist_ID = playlistView->getSelectedPlaylistID();
    #####:  136:            if (selected_playlist_ID <= 0) {
    #####:  137:                cerr << "Error: No playlist selected.\n";
    #####:  138:                break;
        -:  139:            }
        -:  140:
    #####:  141:            PlaylistLibrary& playlistLibrary = ManagerModel::getInstance().getPlaylistLibrary();
    #####:  142:            const auto& playlists = playlistLibrary.getPlaylists();
        -:  143:
    #####:  144:            const string& selected_playlist_name = playlists[selected_playlist_ID - 1].getName();
    #####:  145:            playPlaylist(selected_playlist_name);
    #####:  146:            break;
    #####:  147:        }
        -:  148:
    #####:  149:        case ACTION_EXIT_PLAYLIST_MENU: {
        -:  150:            /* Stop the current media and return to the home screen */
    #####:  151:            PlayingMediaController* playingController = dynamic_cast<PlayingMediaController*>(
    #####:  152:                ManagerController::getInstance().getController("PlayingView"));
        -:  153:
    #####:  154:            if (!playingController) {
    #####:  155:                cerr << "Error: PlayingMediaController not available!\n";
    #####:  156:                break;}
    #####:  157:            playingController->stop();
    #####:  158:            clearTerminal();
    #####:  159:            ManagerController::getInstance().getManagerView()->setView("Default");
    #####:  160:            break;
        -:  161:        }
    #####:  162:        default:
    #####:  163:            cerr << "Invalid action.\n";
    #####:  164:            break;
        -:  165:    }
    #####:  166:}
        -:  167:
        -:  168:/* Create a new playlist with the given name */
    #####:  169:void PlaylistController::createPlaylist(const string& name) {
    #####:  170:    PlaylistLibrary& playlistLibrary = ManagerModel::getInstance().getPlaylistLibrary();
        -:  171:
        -:  172:    /* Check if a playlist with the same name already exists */
    #####:  173:    if (playlistLibrary.getPlaylistByName(name) == nullptr) {
    #####:  174:        playlistLibrary.addPlaylist(Playlist(name));
    #####:  175:        cout << "Playlist '" << name << "' created successfully.\n";
        -:  176:
        -:  177:        /* Save the updated playlists to file */
        -:  178:        try {
    #####:  179:            playlistLibrary.saveToFile("playlists.txt");
    =====:  180:        } catch (const exception& e) {
    =====:  181:            cerr << "Error saving playlist to file: " << e.what() << '\n';
    =====:  182:        }
        -:  183:    } else {
    #####:  184:        cerr << "Playlist with name '" << name << "' already exists.\n";
        -:  185:    }
    #####:  186:}
        -:  187:
        -:  188:/* Delete a playlist */
    #####:  189:void PlaylistController::deletePlaylist() {
    #####:  190:    PlaylistLibrary& playlistLibrary = ManagerModel::getInstance().getPlaylistLibrary();
    #####:  191:    auto& playlists = playlistLibrary.getPlaylists();
        -:  192:
    #####:  193:    if (playlists.empty()) {
    #####:  194:        cout << "No playlists available to delete.\n";
    #####:  195:        return;
        -:  196:    }
        -:  197:
    #####:  198:    PlaylistView* playlistView = dynamic_cast<PlaylistView*>(
    #####:  199:        ManagerController::getInstance().getManagerView()->getView());
    #####:  200:    if (!playlistView) {
    #####:  201:        cerr << "Error: PlaylistView is not available.\n";
    #####:  202:        return;
        -:  203:    }
        -:  204:
        -:  205:    /* Get the selected playlist ID from the view */
    #####:  206:    int selected_playlist_ID = playlistView->getSelectedPlaylistID();
    #####:  207:    if (selected_playlist_ID <= 0 || selected_playlist_ID > static_cast<int>(playlists.size())) {
    #####:  208:        cerr << "Error: Invalid Playlist ID!\n";
    #####:  209:        return;
        -:  210:    }
        -:  211:
        -:  212:    /* Remove the playlist by ID */
    #####:  213:    const string playlistName = playlists[selected_playlist_ID - 1].getName();
    #####:  214:    playlistLibrary.removePlaylist(playlistName);
        -:  215:
    #####:  216:    string notification_message = "Playlist '" + playlistName + "' deleted successfully.";
    #####:  217:    bool success = true;
        -:  218:
        -:  219:    try {
    #####:  220:        playlistLibrary.saveToFile("playlists.txt");
    #####:  221:        notification_message += "\nUpdated playlists saved successfully to file.";
    =====:  222:    } catch (const exception& e) {
    =====:  223:        notification_message = "Error saving updated playlists to file: " + string(e.what());
    =====:  224:        success = false;
    =====:  225:    }
        -:  226:
        -:  227:    /* Display a notification to the user */
    #####:  228:    auto screen = ScreenInteractive::TerminalOutput();
    #####:  229:    auto notification_renderer = Renderer([&] {
    #####:  230:        return vbox({
    #####:  231:            text("Playlist View") | bold | center,
        -:  232:            separator(),
    #####:  233:            text(notification_message) | (success ? color(Color::Green) : color(Color::Red)) | center,
        -:  234:            separator(),
    #####:  235:            text("Press ENTER to return to Playlist View.") | dim | center
    #####:  236:        });
    #####:  237:    });
        -:  238:
        -:  239:    /* Capture user input to return to the playlist view */
    #####:  240:    auto main_component = CatchEvent(notification_renderer, [&](Event event) {
    #####:  241:        if (event == Event::Return) {
    #####:  242:            screen.ExitLoopClosure()();
    #####:  243:            return true;
        -:  244:        }
    #####:  245:        return false;
    #####:  246:    });
        -:  247:
    #####:  248:    screen.Loop(main_component);
    #####:  249:}
        -:  250:
        -:  251:/* View details of a playlist by name */
    #####:  252:void PlaylistController::viewPlaylistDetails(const string& name) {
    #####:  253:    PlaylistLibrary& playlistLibrary = ManagerModel::getInstance().getPlaylistLibrary();
    #####:  254:    Playlist* playlist = playlistLibrary.getPlaylistByName(name);
        -:  255:
    #####:  256:    if (!playlist) {
    #####:  257:        cerr << "Playlist '" << name << "' not found.\n";
    #####:  258:        return;
        -:  259:    }
        -:  260:
    #####:  261:    PlaylistView* playlistView = dynamic_cast<PlaylistView*>(
    #####:  262:        ManagerController::getInstance().getManagerView()->getView());
    #####:  263:    if (!playlistView) {
    #####:  264:        cerr << "Error: PlaylistView is not available.\n";
    #####:  265:        return;
        -:  266:    }
        -:  267:
    #####:  268:    playlistView->displayPlaylistDetails(*playlist);
        -:  269:}
        -:  270:
        -:  271:/* List all available playlists */
    #####:  272:void PlaylistController::listAllPlaylists() {
    #####:  273:    PlaylistLibrary& playlistLibrary = ManagerModel::getInstance().getPlaylistLibrary();
    #####:  274:    PlaylistView* playlistView = dynamic_cast<PlaylistView*>(
    #####:  275:        ManagerController::getInstance().getManagerView()->getView());
        -:  276:
    #####:  277:    if (!playlistView) {
    #####:  278:        cerr << "Error: PlaylistView is not available.\n";
    #####:  279:        return;
        -:  280:    }
        -:  281:
    #####:  282:    auto& playlists = playlistLibrary.getPlaylists();
    #####:  283:    if (playlists.empty()) {
    #####:  284:        cout << "No playlists available.\n";
        -:  285:    } else {
    #####:  286:        playlistView->displayPlaylists(playlists);
        -:  287:    }
        -:  288:}
        -:  289:
        -:  290:/* Play the selected playlist */
    #####:  291:void PlaylistController::playPlaylist(const string& name) {
    #####:  292:    PlaylistLibrary& playlistLibrary = ManagerModel::getInstance().getPlaylistLibrary();
    #####:  293:    Playlist* playlist = playlistLibrary.getPlaylistByName(name);
        -:  294:
    #####:  295:    if (!playlist) {
    #####:  296:        cerr << "Playlist '" << name << "' not found.\n";
    #####:  297:        return;
        -:  298:    }
        -:  299:
    #####:  300:    const auto& songs = playlist->getSongs();
        -:  301:
    #####:  302:    if (songs.empty()) {
    #####:  303:        cerr << "No songs in playlist '" << name << "'.\n";
    #####:  304:        return;
        -:  305:    }
        -:  306:
        -:  307:    /* Switch to the PlayingView */
    #####:  308:    ManagerController::getInstance().getManagerView()->setView("PlayingView");
    #####:  309:    cout << "Playing playlist '" << name << "':\n";
        -:  310:
    #####:  311:    PlayingMediaController* playingMediaController = dynamic_cast<PlayingMediaController*>(
    #####:  312:        ManagerController::getInstance().getController("PlayingView"));
        -:  313:
    #####:  314:    if (!playingMediaController) {
    #####:  315:        cerr << "Error: PlayingMediaController is not available.\n";
    #####:  316:        return;
        -:  317:    }
        -:  318:
        -:  319:    /* Play the selected playlist */
    #####:  320:    playingMediaController->playPlaylist(const_cast<vector<MediaFile>&>(songs));
        -:  321:}
