        -:    0:Source:src/controller/PlayingMediaController.cpp
        -:    0:Graph:build/objects/src/controller/PlayingMediaController.gcno
        -:    0:Data:build/objects/src/controller/PlayingMediaController.gcda
        -:    0:Runs:1
        -:    1:#include "controller/PlayingMediaController.h"
        -:    2:#include "view/PlayingView.h"
        -:    3:#include "controller/PlayingMediaController.h"
        -:    4:#include <SDL2/SDL.h>
        -:    5:#include <SDL2/SDL_ttf.h>
        -:    6:#include <iostream>
        -:    7:#include <string>
        -:    8:#include <sstream>
        -:    9:#include "common/TerminalUtils.h"
        -:   10:
        -:   11:/* Global variables for SDL initialization and state tracking */
        -:   12:bool isSDLInitialized = false;
        -:   13:Mix_Music* currentMusic = nullptr;
        -:   14:atomic<bool> isVideoPlaying{false};
        -:   15:
        -:   16:/* Function to initialize SDL and SDL_mixer */
    #####:   17:void initializeSDL() {
    #####:   18:    if (SDL_Init(SDL_INIT_AUDIO | SDL_INIT_VIDEO) < 0) {
    #####:   19:        cerr << "Failed to initialize SDL: " << SDL_GetError() << "\n";
    #####:   20:        return;
        -:   21:    }
    #####:   22:    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) < 0) {
    #####:   23:        cerr << "Failed to initialize SDL_mixer: " << Mix_GetError() << "\n";
    #####:   24:        return;
        -:   25:    }
    #####:   26:    isSDLInitialized = true;
        -:   27:}
        -:   28:
        -:   29:/* Function to clean up SDL resources */
    #####:   30:void cleanupSDL() {
    #####:   31:    if (currentMusic) {
    #####:   32:        Mix_FreeMusic(currentMusic);
    #####:   33:        currentMusic = nullptr;
        -:   34:    }
    #####:   35:    Mix_CloseAudio();
    #####:   36:    SDL_Quit();
    #####:   37:}
        -:   38:
        -:   39:/* Function to play a video file */
    #####:   40:void PlayingMediaController::handleAction(int choice) {
    #####:   41:    switch (choice) {
    #####:   42:        case ACTION_PLAY_PAUSE: {
        -:   43:            /* Pause or resume the music */
    #####:   44:            if (Mix_PausedMusic()) {
    #####:   45:                Mix_ResumeMusic();
    #####:   46:                isPlaying = true;
    #####:   47:                cout << "Resuming music...\n";
        -:   48:            } else {
    #####:   49:                Mix_PauseMusic();
    #####:   50:                isPlaying = false;
    #####:   51:                cout << "Pausing music...\n";
        -:   52:            }
    #####:   53:            break;
        -:   54:        }
    #####:   55:        case ACTION_SKIP_NEXT:
        -:   56:            /* Skip to the next track */
    #####:   57:            skipToNext();
    #####:   58:            break;
    #####:   59:        case ACTION_SKIP_PREVIOUS:
        -:   60:            /* Skip to the previous track */
    #####:   61:            skipToPrevious();
    #####:   62:            break;
    #####:   63:        case ACTION_ADJUST_VOLUME: {
        -:   64:            /* Adjust the volume level */
        -:   65:            int newVolume;
    #####:   66:            cout << "Enter new volume (0-100): ";
    #####:   67:            cin >> newVolume;
    #####:   68:            adjustVolume(newVolume);
    #####:   69:            break;
        -:   70:        }
    #####:   71:        case ACTION_STOP:
        -:   72:            /* Stop the music */
    #####:   73:            stop();
    #####:   74:            break;
    #####:   75:        case ACTION_EXIT_PLAYING_MENU: {
        -:   76:            /* Stop the music and return to the home screen */
    #####:   77:            isRunning = false;
    #####:   78:            clearTerminal();
    #####:   79:            ManagerController::getInstance().getManagerView()->setView("Default");
        -:   80:        }
    #####:   81:        default:
    #####:   82:            break;
        -:   83:    }
    #####:   84:}
        -:   85:
        -:   86:/* Function to adjust the volume level */
    #####:   87:void PlayingMediaController::adjustVolume(int level) {
    #####:   88:    if (level < 0 || level > 100) {
    #####:   89:        cerr << "Volume level must be between 0 and 100.\n";
    #####:   90:        return;
        -:   91:    }
        -:   92:
    #####:   93:    volume = level;
    #####:   94:    Mix_VolumeMusic((MIX_MAX_VOLUME * volume) / 100);
        -:   95:}
        -:   96:
        -:   97:/* Function to stop the music */
        1:   98:void PlayingMediaController::stop() {
        1:   99:    if (!isPlaying) return;
        -:  100:
    #####:  101:    isRunning = false;
        -:  102:
        -:  103:    /* Wait for the update thread to finish */
    #####:  104:    if (updateThread.joinable() && this_thread::get_id() != updateThread.get_id()) {
    #####:  105:        updateThread.join();
        -:  106:    }
        -:  107:
        -:  108:    /* Stop the music */
    #####:  109:    if (Mix_PlayingMusic()) {
    #####:  110:        Mix_HaltMusic();
        -:  111:    }
        -:  112:
        -:  113:    /* Free the music resource */
    #####:  114:    if (currentMusic) {
    #####:  115:        Mix_FreeMusic(currentMusic);
    #####:  116:        currentMusic = nullptr;
        -:  117:    }
        -:  118:
        -:  119:    /* Reset the current media file */
    #####:  120:    PlayingView* playingView = dynamic_cast<PlayingView*>(
    #####:  121:        ManagerController::getInstance().getManagerView()->getView());
    #####:  122:    if (playingView) {
    #####:  123:        playingView->clearView();
    #####:  124:        playingView->displayPlayingView("No Media", 0, volume, 0);
        -:  125:    }
        -:  126:
    #####:  127:    isPlaying = false;
        -:  128:}
        -:  129:
        -:  130:/* Function to skip to the next track */
    #####:  131:void PlayingMediaController::skipToNext() {
    #####:  132:    stop();
        -:  133:
        -:  134:    /* Skip to the next track in the playlist */
    #####:  135:    if (currentPlaylist && !currentPlaylist->empty()) {
    #####:  136:        currentPlaylistIndex = (currentPlaylistIndex + 1) % currentPlaylist->size();
    #####:  137:        currentMediaFile = &(*currentPlaylist)[currentPlaylistIndex];
        -:  138:    } else {
        -:  139:        /* Skip to the next track in the media library */
    #####:  140:        auto& mediaFiles = ManagerController::getInstance().getManagerModel()->getMediaLibrary().getMediaFiles();
    #####:  141:        if (mediaFiles.empty()) {
    #####:  142:            cerr << "No media files available to skip.\n";
    #####:  143:            return;
        -:  144:        }
        -:  145:
    #####:  146:        if (!currentMediaFile) {
    #####:  147:            currentMediaFile = &mediaFiles.front();
        -:  148:        } else {
    #####:  149:            auto it = find_if(mediaFiles.begin(), mediaFiles.end(),
    #####:  150:                                   [this](const MediaFile& file) { return file.getPath() == currentMediaFile->getPath(); });
    #####:  151:            if (it != mediaFiles.end()) {
    #####:  152:                ++it;
    #####:  153:                currentMediaFile = (it != mediaFiles.end()) ? &(*it) : &mediaFiles.front();
        -:  154:            } else {
    #####:  155:                currentMediaFile = &mediaFiles.front();
        -:  156:            }
        -:  157:        }
        -:  158:    }
        -:  159:
        -:  160:    /* Play the next track */
    #####:  161:    playMediaFile(currentMediaFile);
        -:  162:}
        -:  163:
        -:  164:/* Function to skip to the previous track */
    #####:  165:void PlayingMediaController::skipToPrevious() {
        -:  166:    /* Stop the current music */
    #####:  167:    stop();
        -:  168:
        -:  169:    /* Skip to the previous track in the playlist */
    #####:  170:    if (currentPlaylist && !currentPlaylist->empty()) {
    #####:  171:        currentPlaylistIndex = (currentPlaylistIndex == 0) ? currentPlaylist->size() - 1 : currentPlaylistIndex - 1;
    #####:  172:        currentMediaFile = &(*currentPlaylist)[currentPlaylistIndex];
        -:  173:    } else {
        -:  174:        /* Skip to the previous track in the media library */
    #####:  175:        auto& mediaFiles = ManagerController::getInstance().getManagerModel()->getMediaLibrary().getMediaFiles();
    #####:  176:        if (mediaFiles.empty()) {
    #####:  177:            cerr << "No media files available to skip.\n";
    #####:  178:            return;
        -:  179:        }
        -:  180:
    #####:  181:        if (!currentMediaFile) {
    #####:  182:            currentMediaFile = &mediaFiles.back();
        -:  183:        } else {
    #####:  184:            auto it = find_if(mediaFiles.begin(), mediaFiles.end(),
    #####:  185:                                   [this](const MediaFile& file) { return file.getPath() == currentMediaFile->getPath(); });
    #####:  186:            if (it != mediaFiles.end() && it != mediaFiles.begin()) {
    #####:  187:                --it;
    #####:  188:                currentMediaFile = &(*it);
        -:  189:            } else {
    #####:  190:                currentMediaFile = &mediaFiles.back();
        -:  191:            }
        -:  192:        }
        -:  193:    }
        -:  194:
        -:  195:    /* Play the previous track */
    #####:  196:    playMediaFile(currentMediaFile);
        -:  197:}
        -:  198:
        -:  199:/* Function to play a media file */
    #####:  200:void PlayingMediaController::playMediaFile(MediaFile* mediaFile) {
    #####:  201:    if (!mediaFile) {
    #####:  202:        cerr << "No media file provided.\n";
    #####:  203:        return;
        -:  204:    }
        -:  205:
        -:  206:    /* Get the file path and its extension */
    #####:  207:    string path = mediaFile->getPath();
    #####:  208:    string extension = path.substr(path.find_last_of('.') + 1);
        -:  209:
        -:  210:    /* Check if the media file is a supported audio format */
    #####:  211:    if (extension == "mp3" || extension == "wav" || extension == "ogg") {
    #####:  212:        stop();
    #####:  213:        isRunning = true;
        -:  214:
    #####:  215:        if (!isSDLInitialized) {
    #####:  216:            initializeSDL();
    #####:  217:            if (!isSDLInitialized) {
    #####:  218:                cerr << "Failed to initialize SDL.\n";
    #####:  219:                return;
        -:  220:            }
        -:  221:        }
        -:  222:
        -:  223:        /* Load the music file */
    #####:  224:        currentMusic = Mix_LoadMUS(path.c_str());
    #####:  225:        if (!currentMusic) {
    #####:  226:            cerr << "Failed to load music file: " << path << " (" << Mix_GetError() << ")\n";
    #####:  227:            return;
        -:  228:        }
        -:  229:
        -:  230:        /* Start playing the music */
    #####:  231:        if (Mix_PlayMusic(currentMusic, 1) == -1) {
    #####:  232:            cerr << "Failed to play music: " << Mix_GetError() << "\n";
    #####:  233:            return;
        -:  234:        }
        -:  235:
        -:  236:        /* Set a callback for when the music finishes */
    #####:  237:        Mix_HookMusicFinished([]() {
    #####:  238:            PlayingMediaController* controller = dynamic_cast<PlayingMediaController*>(
    #####:  239:                ManagerController::getInstance().getController("PlayingMedia"));
    #####:  240:            if (controller) {
    #####:  241:                controller->skipToNext();
        -:  242:            }
    #####:  243:        });
        -:  244:
        -:  245:        /* Update the current media file and state */
    #####:  246:        currentMediaFile = mediaFile;
    #####:  247:        isPlaying = true;
        -:  248:
        -:  249:        /* Get the total time of the music file */
    #####:  250:        auto fileRef = TagLib::FileRef(path.c_str());
    #####:  251:        totalTime = fileRef.audioProperties() ? fileRef.audioProperties()->length() : 0;
    #####:  252:        currentTime = 0;
        -:  253:
        -:  254:        /* Start the display loop */
    #####:  255:        startDisplayLoop();
        -:  256:
    #####:  257:    } else if (extension == "mp4" || extension == "avi" || extension == "mkv") {
        -:  258:        /* Play the video file */
    #####:  259:        isVideoPlaying = true;
    #####:  260:        thread videoThread([this, path]() {
    #####:  261:            playVideo(path);
    #####:  262:            isVideoPlaying = false;
        -:  263:
        -:  264:            /* Trigger an SDL user event to indicate video completion */
        -:  265:            SDL_Event event;
    #####:  266:            event.type = SDL_USEREVENT;
    #####:  267:            event.user.code = 1;
    #####:  268:            SDL_PushEvent(&event);
    #####:  269:        });
    #####:  270:        videoThread.detach();
        -:  271:
    #####:  272:    } else {
    #####:  273:        cerr << "Unsupported file format: " << extension << "\n";
        -:  274:    }
    #####:  275:}
        -:  276:
        -:  277:/* Start a loop to continuously update the playing view */
    #####:  278:void PlayingMediaController::startDisplayLoop() {
    #####:  279:    if (updateThread.joinable()) {
        -:  280:        /* If a display loop is already running, ensure it updates correctly */
    #####:  281:        cout << "Display loop is already running. Ensuring updates...\n";
    #####:  282:        isRunning = true;
    #####:  283:        return;
        -:  284:    }
        -:  285:
        -:  286:    /* Retrieve the PlayingView instance */
    #####:  287:    PlayingView* playingView = dynamic_cast<PlayingView*>(
    #####:  288:        ManagerController::getInstance().getManagerView()->getView());
    #####:  289:    if (!playingView) {
    #####:  290:        cerr << "PlayingView not available.\n";
    #####:  291:        return;
        -:  292:    }
        -:  293:
        -:  294:    /* Start a new thread for updating the playing view */
    #####:  295:    updateThread = thread([this, playingView]() {
    #####:  296:        while (isRunning) {
        -:  297:            {
    #####:  298:                lock_guard<mutex> lock(mediaMutex);
        -:  299:
        -:  300:                /* Update the playing view with the current media details */
    #####:  301:                playingView->clearView();
    #####:  302:                playingView->displayPlayingView(
    #####:  303:                    currentMediaFile ? currentMediaFile->getName() : "No Media",
        -:  304:                    totalTime.load(),
        -:  305:                    volume,
        -:  306:                    currentTime.load()
        -:  307:                );
    #####:  308:            }
        -:  309:
        -:  310:            /* Wait for 1 second before updating the view again */
    #####:  311:            this_thread::sleep_for(chrono::seconds(1));
        -:  312:
    #####:  313:            if (isPlaying) {
    #####:  314:                ++currentTime;
    #####:  315:                if (currentTime >= totalTime) {
        -:  316:                    /* If playback is finished, skip to the next track */
    #####:  317:                    cout << "\nPlayback finished. Skipping to next track...\n";
    #####:  318:                    isRunning = false;
    #####:  319:                    skipToNext();
        -:  320:                }
        -:  321:            }
        -:  322:        }
    #####:  323:    });
        -:  324:}
        -:  325:
        -:  326:/* Play a playlist of media files */
    #####:  327:void PlayingMediaController::playPlaylist(vector<MediaFile>& playlist) {
    #####:  328:    currentPlaylist = &playlist;
    #####:  329:    currentPlaylistIndex = 0;
        -:  330:
    #####:  331:    if (!playlist.empty()) {
        -:  332:        /* Play the first media file in the playlist */
    #####:  333:        currentMediaFile = &playlist[currentPlaylistIndex];
    #####:  334:        playMediaFile(currentMediaFile);
        -:  335:    } else {
    #####:  336:        cerr << "Playlist is empty.\n";
        -:  337:    }
    #####:  338:}
        -:  339:
        -:  340:/* Getter for the currently playing media file */
    #####:  341:MediaFile* PlayingMediaController::getCurrentMediaFile() const {
    #####:  342:    return currentMediaFile;
        -:  343:}
        -:  344:
        -:  345:/* Check if media is currently playing */
    #####:  346:bool PlayingMediaController::isCurrentlyPlaying() const {
    #####:  347:    return isPlaying;
        -:  348:}
        -:  349:
        -:  350:/* Get the index of the currently playing item in the playlist */
    #####:  351:size_t PlayingMediaController::getCurrentPlaylistIndex() const {
    #####:  352:    return currentPlaylistIndex;
        -:  353:}
        -:  354:
        -:  355:/* Get the current playlist */
    #####:  356:vector<MediaFile>* PlayingMediaController::getCurrentPlaylist() const {
    #####:  357:    return currentPlaylist;
        -:  358:}
        -:  359:
        -:  360:/* Set the currently playing media file */
    #####:  361:void PlayingMediaController::setCurrentMediaFile(MediaFile* mediaFile) {
    #####:  362:    lock_guard<mutex> lock(mediaMutex);
    #####:  363:    currentMediaFile = mediaFile;
    #####:  364:}
        -:  365:
        -:  366:/* Set the playing state */
    #####:  367:void PlayingMediaController::setIsPlaying(bool playing) {
    #####:  368:    lock_guard<mutex> lock(mediaMutex);
    #####:  369:    isPlaying = playing;
    #####:  370:}
        -:  371:
        -:  372:/* Set the current playlist */
    #####:  373:void PlayingMediaController::setCurrentPlaylist(vector<MediaFile>* playlist) {
    #####:  374:    lock_guard<mutex> lock(mediaMutex);
    #####:  375:    currentPlaylist = playlist;
    #####:  376:}
        -:  377:
        -:  378:/* Set the current playlist index */
    #####:  379:void PlayingMediaController::setCurrentPlaylistIndex(size_t index) {
    #####:  380:    lock_guard<mutex> lock(mediaMutex);
    #####:  381:    currentPlaylistIndex = index;
    #####:  382:}
        -:  383:
        -:  384:/* Get the total playback time of the current media */
    #####:  385:int PlayingMediaController::getTotalTime() const {
    #####:  386:    return totalTime.load();
        -:  387:}
        -:  388:
        -:  389:/* Get the current playback time of the media */
    #####:  390:int PlayingMediaController::getCurrentTime() const {
    #####:  391:    return currentTime.load();
        -:  392:}
        -:  393:
        -:  394:/* Get the current volume level */
    #####:  395:int PlayingMediaController::getVolume() const {
    #####:  396:    return volume;
        -:  397:}
        -:  398:
        -:  399:/* Refresh the playing view with updated details */
    #####:  400:void PlayingMediaController::refreshPlayingView() {
    #####:  401:    PlayingView* playingView = dynamic_cast<PlayingView*>(
    #####:  402:        ManagerController::getInstance().getManagerView()->getView());
    #####:  403:    if (playingView && currentMediaFile) {
    #####:  404:        playingView->clearView();
    #####:  405:        playingView->displayPlayingView(
    #####:  406:            currentMediaFile->getName(),
        -:  407:            totalTime.load(),
        -:  408:            volume,
        -:  409:            currentTime.load()
        -:  410:        );
        -:  411:    }
    #####:  412:}
        -:  413:
        -:  414:/* Play a video file using FFmpeg and SDL */
    #####:  415:void PlayingMediaController::playVideo(const string& videoPath) {
        -:  416:    /* Allocate the format context for the video file */
    #####:  417:    AVFormatContext* formatContext = avformat_alloc_context();
    #####:  418:    if (avformat_open_input(&formatContext, videoPath.c_str(), nullptr, nullptr) != 0) {
    #####:  419:        cerr << "Failed to open video file: " << videoPath << "\n";
    #####:  420:        return;
        -:  421:    }
        -:  422:
        -:  423:    /* Retrieve stream information from the video file */
    #####:  424:    if (avformat_find_stream_info(formatContext, nullptr) < 0) {
    #####:  425:        cerr << "Failed to retrieve stream info.\n";
    #####:  426:        avformat_close_input(&formatContext);
    #####:  427:        return;
        -:  428:    }
        -:  429:
        -:  430:    /* Identify the video stream in the file */
    #####:  431:    int videoStreamIndex = -1;
    #####:  432:    for (unsigned int i = 0; i < formatContext->nb_streams; i++) {
    #####:  433:        if (formatContext->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
    #####:  434:            videoStreamIndex = i;
    #####:  435:            break;
        -:  436:        }
        -:  437:    }
        -:  438:
        -:  439:    /* Check if a video stream was found */
    #####:  440:    if (videoStreamIndex == -1) {
    #####:  441:        cerr << "No video stream found.\n";
    #####:  442:        avformat_close_input(&formatContext);
    #####:  443:        return;
        -:  444:    }
        -:  445:
        -:  446:    /* Retrieve the codec parameters for the video stream */
    #####:  447:    AVCodecParameters* codecParams = formatContext->streams[videoStreamIndex]->codecpar;
    #####:  448:    AVStream* videoStream = formatContext->streams[videoStreamIndex];
    #####:  449:    AVCodec* codec = avcodec_find_decoder(codecParams->codec_id);
    #####:  450:    if (!codec) {
    #####:  451:        cerr << "Unsupported codec.\n";
    #####:  452:        avformat_close_input(&formatContext);
    #####:  453:        return;
        -:  454:    }
        -:  455:
        -:  456:    /* Allocate and configure the codec context */
    #####:  457:    AVCodecContext* codecContext = avcodec_alloc_context3(codec);
    #####:  458:    if (avcodec_parameters_to_context(codecContext, codecParams) < 0) {
    #####:  459:        cerr << "Failed to copy codec parameters.\n";
    #####:  460:        avcodec_free_context(&codecContext);
    #####:  461:        avformat_close_input(&formatContext);
    #####:  462:        return;
        -:  463:    }
        -:  464:
        -:  465:    /* Open the codec for decoding */
    #####:  466:    if (avcodec_open2(codecContext, codec, nullptr) < 0) {
    #####:  467:        cerr << "Failed to open codec.\n";
    #####:  468:        avcodec_free_context(&codecContext);
    #####:  469:        avformat_close_input(&formatContext);
    #####:  470:        return;
        -:  471:    }
        -:  472:
        -:  473:    /* Initialize SDL for video rendering */
    #####:  474:    if (SDL_Init(SDL_INIT_VIDEO) != 0 || TTF_Init() != 0) {
    #####:  475:        cerr << "Failed to initialize SDL or SDL_ttf: " << SDL_GetError() << "\n";
    #####:  476:        avcodec_free_context(&codecContext);
    #####:  477:        avformat_close_input(&formatContext);
    #####:  478:        return;
        -:  479:    }
        -:  480:
        -:  481:    /* Create a window and renderer for displaying the video */
    #####:  482:    SDL_Window* window = SDL_CreateWindow("Video Player", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 600, SDL_WINDOW_SHOWN);
    #####:  483:    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, 0);
    #####:  484:    SDL_Texture* texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_YV12, SDL_TEXTUREACCESS_STREAMING, codecParams->width, codecParams->height);
        -:  485:
        -:  486:    /* Load a font for displaying video information */
    #####:  487:    TTF_Font* font = TTF_OpenFont("/usr/share/fonts/truetype/dejavu/DejaVuSerif.ttf", 24);
    #####:  488:    if (!font) {
    #####:  489:        cerr << "Failed to load font: " << TTF_GetError() << "\n";
    #####:  490:        SDL_DestroyRenderer(renderer);
    #####:  491:        SDL_DestroyWindow(window);
    #####:  492:        avcodec_free_context(&codecContext);
    #####:  493:        avformat_close_input(&formatContext);
    #####:  494:        return;
        -:  495:    }
        -:  496:
    #####:  497:    SDL_Color white = {255, 255, 255, 255};
    #####:  498:    ostringstream infoStream;
    #####:  499:    infoStream << "Resolution: " << codecParams->width << "x" << codecParams->height << "\n"
        -:  500:               << "Codec: " << avcodec_get_name(codecParams->codec_id) << "\n"
    #####:  501:               << "Frame Rate: " << av_q2d(videoStream->avg_frame_rate) << " FPS\n"
    #####:  502:               << "Duration: " << (formatContext->duration / AV_TIME_BASE) << " seconds";
        -:  503:
    #####:  504:    string videoInfo = infoStream.str();
    #####:  505:    SDL_Surface* textSurface = TTF_RenderText_Blended_Wrapped(font, videoInfo.c_str(), white, 800);
    #####:  506:    SDL_Texture* textTexture = SDL_CreateTextureFromSurface(renderer, textSurface);
    #####:  507:    SDL_Rect textRect = {10, 10, textSurface->w, textSurface->h};
    #####:  508:    SDL_FreeSurface(textSurface);
        -:  509:
        -:  510:    /* Allocate frames and buffers for decoding and rendering */
    #####:  511:    AVFrame* frame = av_frame_alloc();
    #####:  512:    AVFrame* frameYUV = av_frame_alloc();
    #####:  513:    SwsContext* swsContext = sws_getContext(
        -:  514:        codecParams->width, codecParams->height, codecContext->pix_fmt,
        -:  515:        codecParams->width, codecParams->height, AV_PIX_FMT_YUV420P,
        -:  516:        SWS_BILINEAR, nullptr, nullptr, nullptr);
        -:  517:
    #####:  518:    int bufferSize = av_image_get_buffer_size(AV_PIX_FMT_YUV420P, codecParams->width, codecParams->height, 1);
    #####:  519:    uint8_t* buffer = (uint8_t*)av_malloc(bufferSize);
    #####:  520:    av_image_fill_arrays(frameYUV->data, frameYUV->linesize, buffer, AV_PIX_FMT_YUV420P, codecParams->width, codecParams->height, 1);
        -:  521:
        -:  522:    /* Read and decode video frames */
    #####:  523:    AVPacket* packet = av_packet_alloc();
        -:  524:    SDL_Event event;
    #####:  525:    isVideoPlaying = true;
        -:  526:
    #####:  527:    while (isVideoPlaying) {
        -:  528:        /* Handle SDL events */
    #####:  529:        while (SDL_PollEvent(&event)) {
    #####:  530:            if (event.type == SDL_QUIT) {
    #####:  531:                isVideoPlaying = false;
    #####:  532:            } else if (event.type == SDL_KEYDOWN) {
    #####:  533:                if (event.key.keysym.sym == SDLK_ESCAPE) {
    #####:  534:                    isVideoPlaying = false;
        -:  535:                }
    #####:  536:            } else if (event.type == SDL_USEREVENT && event.user.code == 1) {
    #####:  537:                auto* controller = dynamic_cast<PlayingMediaController*>(
    #####:  538:                    ManagerController::getInstance().getController("PlayingMedia"));
    #####:  539:                if (controller) {
    #####:  540:                    controller->skipToNext();
        -:  541:                }
        -:  542:            }
        -:  543:        }
        -:  544:
    #####:  545:        int ret = av_read_frame(formatContext, packet);
        -:  546:        /* Check for end of video file or error reading frame */
    #####:  547:        if (ret < 0) {
    #####:  548:            if (ret == AVERROR_EOF) {
    #####:  549:                cout << "End of video file reached. Skipping to next media...\n";
    #####:  550:                isVideoPlaying = false;
        -:  551:
        -:  552:                SDL_Event event;
    #####:  553:                event.type = SDL_USEREVENT;
    #####:  554:                event.user.code = 1;
    #####:  555:                SDL_PushEvent(&event);
        -:  556:            } else {
    #####:  557:                cerr << "Error reading frame: " << ret << "\n";
        -:  558:            }
    #####:  559:            break;
        -:  560:        }
        -:  561:
        -:  562:        /* Decode and render video frames */
    #####:  563:        if (packet->stream_index == videoStreamIndex) {
    #####:  564:            if (avcodec_send_packet(codecContext, packet) >= 0) {
    #####:  565:                while (avcodec_receive_frame(codecContext, frame) >= 0) {
    #####:  566:                    sws_scale(swsContext, frame->data, frame->linesize, 0, codecParams->height,
    #####:  567:                            frameYUV->data, frameYUV->linesize);
    #####:  568:                    SDL_UpdateYUVTexture(texture, nullptr, frameYUV->data[0], frameYUV->linesize[0],
    #####:  569:                                        frameYUV->data[1], frameYUV->linesize[1], frameYUV->data[2], frameYUV->linesize[2]);
    #####:  570:                    SDL_RenderClear(renderer);
    #####:  571:                    SDL_RenderCopy(renderer, texture, nullptr, nullptr);
    #####:  572:                    SDL_RenderCopy(renderer, textTexture, nullptr, &textRect);
    #####:  573:                    SDL_RenderPresent(renderer);
    #####:  574:                    SDL_Delay(40);
        -:  575:                }
        -:  576:            }
        -:  577:        }
    #####:  578:        av_packet_unref(packet);
        -:  579:    }
        -:  580:
        -:  581:    /* Clean up resources */
    #####:  582:    SDL_DestroyTexture(textTexture);
    #####:  583:    TTF_CloseFont(font);
    #####:  584:    av_packet_free(&packet);
    #####:  585:    av_free(buffer);
    #####:  586:    av_frame_free(&frameYUV);
    #####:  587:    av_frame_free(&frame);
    #####:  588:    sws_freeContext(swsContext);
    #####:  589:    SDL_DestroyTexture(texture);
    #####:  590:    SDL_DestroyRenderer(renderer);
    #####:  591:    SDL_DestroyWindow(window);
    #####:  592:    TTF_Quit();
    #####:  593:    SDL_Quit();
    #####:  594:    avcodec_free_context(&codecContext);
    #####:  595:    avformat_close_input(&formatContext);
    #####:  596:}
