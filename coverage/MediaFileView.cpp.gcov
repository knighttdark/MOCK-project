        -:    0:Source:src/view/MediaFileView.cpp
        -:    0:Graph:build/objects/src/view/MediaFileView.gcno
        -:    0:Data:build/objects/src/view/MediaFileView.gcda
        -:    0:Runs:1
        -:    1:#include "view/MediaFileView.h"
        -:    2:#include <common/TerminalUtils.h>
        -:    3:#include <common/Exception.h>
        -:    4:#include "controller/MediaFileController.h"
        -:    5:#include "common/Enum.h"
        -:    6:
    #####:    7:int MediaFileView::getSelectedMediaID() const {
    #####:    8:    return selected_media_ID;
        -:    9:}
        -:   10:
    #####:   11:void MediaFileView::setSelectedMediaID(int id) {
    #####:   12:    selected_media_ID = id;
    #####:   13:}
        -:   14:
    #####:   15:int MediaFileView::showMenu() {
        -:   16:    MenuRenderer menu("Media File Menu",
        -:   17:                      {"1. Show Metadata",
        -:   18:                       "2. Play Song", "3. Add to Playlist","4. Return to Playing", "0. Return Home"},
    #####:   19:                      {1, 2, 3, 4, 0});
        -:   20:
    #####:   21:    return menu.render();
    #####:   22:}
        -:   23:
    #####:   24:void MediaFileView::displayMediaFiles(const vector<string>& medialist, int page, const string& notification_message) {
    #####:   25:    if (medialist.empty()) {
    #####:   26:        auto empty_renderer = Renderer([] {
    #####:   27:            return vbox({
    #####:   28:                text("No media files available.") | bold | center,
        -:   29:                separator(),
    #####:   30:                text("Press ENTER to return.") | dim | center
    #####:   31:            }) | center;
    #####:   32:        });
        -:   33:
    #####:   34:        auto screen = ScreenInteractive::TerminalOutput();
    #####:   35:        auto main_component = CatchEvent(empty_renderer, [&](Event event) {
    #####:   36:            if (event == Event::Return) {
    #####:   37:                screen.ExitLoopClosure()();
    #####:   38:                return true;
        -:   39:            }
    #####:   40:            return false;
    #####:   41:        });
        -:   42:
    #####:   43:        screen.Loop(main_component);
    #####:   44:        return;
    #####:   45:    }
        -:   46:
    #####:   47:    int selected_index = 0;
        -:   48:
    #####:   49:    auto media_menu = Menu(&medialist, &selected_index);
        -:   50:
    #####:   51:    auto screen = ScreenInteractive::TerminalOutput();
        -:   52:
    #####:   53:    auto main_renderer = Renderer(media_menu, [&] {
    #####:   54:        return vbox({
    #####:   55:                   text("==== Media Files (Page " + to_string(page) +") ====") | bold | center,
        -:   56:                   separator(),
    #####:   57:                   media_menu->Render() | border,
        -:   58:                   separator(),
    #####:   59:                   text(notification_message) | color(Color::Green) | center,
        -:   60:                   separator(),
    #####:   61:                   hbox({
        -:   62:                       text("Press ENTER to select | "),
    #####:   63:                       text("Page Controls: <- Previous | -> Next ") | dim
        -:   64:                   }) | center
        -:   65:               }) |
    #####:   66:               center;
    #####:   67:    });
        -:   68:
    #####:   69:    bool next_page = false;
    #####:   70:    bool previous_page = false;
        -:   71:
    #####:   72:    auto main_component = CatchEvent(main_renderer, [&](Event event) {
    #####:   73:        if (event == Event::Return) {
    #####:   74:            if (selected_index >= 0 && selected_index < (int)medialist.size()) {
    #####:   75:                setSelectedMediaID(selected_index + 1);
    #####:   76:                screen.ExitLoopClosure()();
        -:   77:            }
    #####:   78:            return true;
        -:   79:        }
        -:   80:
    #####:   81:        if (event == Event::ArrowRight) {
    #####:   82:            next_page = true;
    #####:   83:            screen.ExitLoopClosure()();
    #####:   84:            return true;
        -:   85:        }
        -:   86:
    #####:   87:        if (event == Event::ArrowLeft) {
    #####:   88:            previous_page = true;
    #####:   89:            screen.ExitLoopClosure()();
    #####:   90:            return true;
        -:   91:        }
        -:   92:
    #####:   93:        if (event.is_mouse() && event.mouse().button == Mouse::Left && event.mouse().motion == Mouse::Pressed) {
    #####:   94:            int clicked_index = event.mouse().y - 3;
    #####:   95:            if (clicked_index >= 0 && clicked_index < (int)medialist.size()) {
    #####:   96:                selected_index = clicked_index;
    #####:   97:                setSelectedMediaID(selected_index + 1);
    #####:   98:                screen.ExitLoopClosure()();
        -:   99:            }
    #####:  100:            return true;
        -:  101:        }
    #####:  102:        return media_menu->OnEvent(event);
    #####:  103:    });
        -:  104:
    #####:  105:    screen.Loop(main_component);
        -:  106:
    #####:  107:    if (next_page) {
    #####:  108:        MediaFileController* mediaFileController = dynamic_cast<MediaFileController*>(
    #####:  109:            ManagerController::getInstance().getController("MediaFile"));
        -:  110:
        -:  111:        /* Check if the MediaFileController is available */
    #####:  112:        if (!mediaFileController) {
    #####:  113:            cerr << "Error: MediaFileController is not available!" << endl;
        -:  114:        }
    #####:  115:        mediaFileController ->handleAction(ACTION_NEXT_PAGE);
    #####:  116:    } else if (previous_page) {
    #####:  117:        MediaFileController* mediaFileController = dynamic_cast<MediaFileController*>(
    #####:  118:            ManagerController::getInstance().getController("MediaFile"));
        -:  119:
        -:  120:        /* Check if the MediaFileController is available */
    #####:  121:        if (!mediaFileController) {
    #####:  122:            cerr << "Error: MediaFileController is not available!" << endl;
        -:  123:        }
    #####:  124:        mediaFileController ->handleAction(ACTION_PREVIOUS_PAGE);
        -:  125:    }
    #####:  126:}
        -:  127:
    #####:  128:void MediaFileView::displayPagination(int currentPage, int totalPages) {
    #####:  129:    cout << "\nPage " << currentPage << " of " << totalPages << '\n';
    #####:  130:}
        -:  131:
    #####:  132:string MediaFileView::promptDirectoryInput() {
    #####:  133:    string path = "";
    #####:  134:    string error_message = "";
        -:  135:
    #####:  136:    auto input_box = Input(&path, "Enter directory path:");
        -:  137:
    #####:  138:    auto screen = ScreenInteractive::TerminalOutput();
        -:  139:
    #####:  140:    auto main_component = Renderer(input_box, [&] {
    #####:  141:        return vbox({
    #####:  142:            text("==== Enter Directory Path ====") | center,
        -:  143:            separator(),
    #####:  144:            input_box->Render() | border,
        -:  145:            separator(),
    #####:  146:            error_message.empty()
    #####:  147:                ? text("Press Enter to confirm the input.") | dim | center
    #####:  148:                : text(error_message) | color(Color::Red) | center,
    #####:  149:        });
    #####:  150:    });
        -:  151:
    #####:  152:    main_component = CatchEvent(main_component, [&](Event event) {
    #####:  153:        if (event == Event::Return) {
        -:  154:            try {
    #####:  155:                Exception::checkInputFilePath(path);
    #####:  156:                screen.ExitLoopClosure()();
    #####:  157:                return true;
    =====:  158:            } catch (const invalid_argument& e) {
    =====:  159:                error_message = e.what();
    =====:  160:                return true;
    =====:  161:            }
        -:  162:        }
    #####:  163:        return false;
    #####:  164:    });
        -:  165:
    #####:  166:    screen.Loop(main_component);
        -:  167:
    #####:  168:    return path;
    #####:  169:}
        -:  170:
        -:  171:
        -:  172:
    #####:  173:int MediaFileView::showOptionScan() {
        -:  174:    vector<string> menu_entries = {
        -:  175:        "1. Scan Directory",
        -:  176:        "2. Scan USB",
        -:  177:        "0. Return Home"
    #####:  178:    };
        -:  179:
    #####:  180:    vector<int> logic_mapping = {1, 2, 0};
        -:  181:
    #####:  182:    int selected = 0;
    #####:  183:    string error_message;
    #####:  184:    int final_selected = -1;
        -:  185:
    #####:  186:    auto menu = Menu(&menu_entries, &selected);
        -:  187:
    #####:  188:    auto screen = ScreenInteractive::TerminalOutput();
        -:  189:
    #####:  190:    auto main_component = Renderer(menu, [&] {
    #####:  191:        return vbox({
    #####:  192:            text("==== Scan Options ====") | center,
        -:  193:            separator(),
    #####:  194:            menu->Render() | border,
        -:  195:            separator(),
    #####:  196:            text("Use UP/DOWN keys, numbers (0-2), or click to navigate. Press ENTER to select.") | dim | center,
        -:  197:            separator(),
    #####:  198:            text(error_message) | color(Color::Red) | center
    #####:  199:        });
    #####:  200:    });
        -:  201:
    #####:  202:    main_component = CatchEvent(main_component, [&](Event event) {
    #####:  203:        if (event == Event::Return) {
    #####:  204:            final_selected = logic_mapping[selected];
    #####:  205:            screen.ExitLoopClosure()();
    #####:  206:            return true;
        -:  207:        }
        -:  208:
    #####:  209:        if (event.is_character() && isdigit(event.character()[0])) {
    #####:  210:            int number = event.character()[0] - '0';
    #####:  211:            auto it = find(logic_mapping.begin(), logic_mapping.end(), number);
    #####:  212:            if (it != logic_mapping.end()) {
    #####:  213:                final_selected = number;
    #####:  214:                screen.ExitLoopClosure()();
    #####:  215:                return true;
        -:  216:            } else {
    #####:  217:                error_message = "Invalid input: number not in menu!";
    #####:  218:                return true;
        -:  219:            }
        -:  220:        }
        -:  221:
    #####:  222:        if (event.is_mouse() && event.mouse().button == Mouse::Left && event.mouse().motion == Mouse::Pressed) {
    #####:  223:            int clicked_index = event.mouse().y - 3;
    #####:  224:            if (clicked_index >= 0 && clicked_index < (int)menu_entries.size()) {
    #####:  225:                final_selected = logic_mapping[clicked_index];
    #####:  226:                screen.ExitLoopClosure()();
    #####:  227:                return true;
        -:  228:            } else {
    #####:  229:                error_message = "Invalid click: out of menu range!";
    #####:  230:                return true;
        -:  231:            }
        -:  232:        }
        -:  233:
    #####:  234:        if (event == Event::ArrowUp || event == Event::ArrowDown) {
    #####:  235:            menu->OnEvent(event);
    #####:  236:            return true;
        -:  237:        }
        -:  238:
    #####:  239:        return false;
    #####:  240:    });
        -:  241:
    #####:  242:    screen.Loop(main_component);
        -:  243:
    #####:  244:    return final_selected;
    #####:  245:}
